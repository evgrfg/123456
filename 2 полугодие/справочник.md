#2 

print('x y z w') - выводит данные на печать

for i in range(1, 100, 10): - цикл с параметрами (от, до, шаг)

  if (not(y<=x) or (z<=w) or not(z))==False: # if - постановка условия; not - инверсия, or - или, <= - импликация, == - равенство
    
  elif y = 10000:
  
  else:
  
#3

На все таблицы поставить фильтр

#4

   1) Построить двоичное дерево дерево с известными данными
   
   2) Определить количество нужных для кодировки символов 
   
   3) Начать кодировку с минимальной длины кода. Посмотреть, хватает ли оставшийся вариантов, что закодировать остальное символы
   
   4) Если не хватает вариантов для кодирования оставшихся символов - увеличиваем длину кода
 
#5

num=(bin(i)[2:])- задаётся значение переменной, с пепероводом числа в двоичную СС и срезом лишних символов

num.count('1')%2==0 - подсчёт определённых символов в строке, с проверкой остатка на равенство нулю

int(chislo,2) - перевод числа из указанной СС в десятичную

break - прерывание цикла

#6
from turtle import * - импотируется всё из указанной библиотеки

left(90) - поворот влево на указанный угол

forward(300) - продвижение вперёд на указанное значение

right(120) - поворот вправо на указанный угол

pu() - поднятие пера

goto(x*30,y*30) - перемещение пера в указанную координату

dot(5) - постановка точки заданной величины

done() - окно остаётся открытым 

#8

s.index('6') - выводит индекс указанного элемента в итерируемом объекте

len(s) - выводит длину итерируемого объекта

t.split(";")- разбивает итерируемый объект по указанному знаку

numb=''.join(n) - соединяет символы или добавляет символ в конец объекта

sp.append(x) - добавляет элемент в конец списка

#9

result = list(map(int, text)) - создаёт список с преобразованием элементов в указанный тип данных

while True: - бесконечный цикл

res6.remove(element) - удаление элемента по значению

sum(res6) - сумма элементов

#10

Открываем расширенный поиск в ворде и ставим галочки у позиций: учитывать регист и всё слово целиком

#12

if all(num%delit!=0 for delit in range(2,num)) - если се условия правда

#13
накопительно нумеруем вершины графа, потом суммируем/умножаем полученные значения
 
 ![image](https://user-images.githubusercontent.com/114381884/208363284-7f150ee5-5b91-4ae4-95ca-32f9e9d1f804.png)

#14

15**4 - возведение левого числа в степень правого

sum10//14 - целочисленное деление

#17

with open('17.txt') as f: - импорт элементов из файла

nums[i] - вывод элемента по его индексу

abs() - модуль

#19, 20, 21   

 1) Определить точку входа (условие выигрыша, то сколько очков нужно набрать)

2) Расписать двоичное дерево на четыре хода
             
3) Ответить на вопрос задачи, присвоив ход игроку
             
4) Расписывая таблицу на четыре хода, получаем решение всех трёх задач

1) расписать через простой граф и найти минимальное значение

2) рассматриваем два варианта позиции после первого хода

3) расписываем для этих варинатов минимальные и максимальные дейтсвия

4) расписываем максимальный ход пети через минимальный ход вани

5) берем ход вани, где он делает +1 второй куче, расписываем пограничные дейтсвия......
             
   ```mermaid
stateDiagram-v2
    >=129 --> 128: +1
    >=129 --> 65: *2
    65 --> 64: +1
    64 --> 63: +1
    64 --> 32: *2
    63 --> 62: +1
    32 --> 16: *2
    32 --> 31: +1
    128 --> 64: *2
    128 --> 127: +1
    127 --> 126: +1
    126 --> 63: *2
    126 --> 125: +1
   ```

#23

from itertools import product - импорт метода из библиотеки

nums=product('12',repeat=i) - генерация объекта

continue - переход к следующшему шагу в for

return count - возвращает значение

pass - заглушка

#24

with open('24.txt') as f:

   let=f.readline() - чтение из файла
   
s.replace('A','G') - одна фигня в строке заменятся на другую 

#25

from operator import itemgetter

sorted(itogo, key=itemgetter(1)) -  сортировка по указываемому номеру элемента

#26

s=sorted(s[1:],reverse=True) - сортировка с конца

#27

min_s = min(s,min_s) - выводит минимальное значение

round() - округление
