2. 1) Сгенерировать всевозможные сочетания переменных

   2) Проверить логическкую функцию на условие
   
   3) Сопоставить вывод с таблицей из задания
``` python
    print('x y z w')
    for x in range(2):
       for y in range(2):       
          for z in range(2):          
             for w in range(2):             
                if (not(y<=x) or (z<=w) or not(z))==False:                
                   print(x, y, z, w)
```
3. На все таблицы поставить фильтр
             
4. 1) Построить двоичное дерево дерево с известными данными
   
   2) Определить количество нужных для кодировки символов 
   
   3) Начать кодировку с минимальной длины кода. Посмотреть, хватает ли оставшийся вариантов, что закодировать остальное символы
   
   4) Если не хватает вариантов для кодирования оставшихся символов - увеличиваем длину кода
 
5. 1) организовать цикл перебора с 0 до числа в условии ответа

   2) перевод в двоичную систему счисления(через bin и через f) 
   
   3) проверяем по условию, дописываем, заменяем

   4) переводим в десятичную систему и проверяем на условие
```python  
   for i in range(1,100):
    chislo=''
    num=(bin(i)[2:])   
    if num.count('1')%2==0:
        chislo='10'+num[2:]+'0'
    if num.count('1')%2!=0:    
        chislo='11'+num[2:]+'1'        
    if int(chislo,2)>40:    
        print (i, int(chislo,2))        
        break
   ```

6. 1) вспомнить команды turtle

   2) Нарисовать по алгоритму
   
   3) Поднять перо и нарисовать точки с учётом масштаба
   
   4) Посчитать вручную
   
8. 1)сгенерировать все возможные варианты чисел(for/product)

   2)проверить строчку на условия
   
   3)выводим счетчик значений
10. Открываем расширенный поиск в ворде и ставим галочки у позиций: учитывать регист и всё слово целиком

12. д

``` python
   spisok=[]
for num in range(2,1000):
  n=0
  for delit in range (2,100):
    if num%delit==0 and x<i: n+=1
  
  if n==0:spisok.append(num)
        
flag=False
for i in spisok:
    for y in range (100):
        if y*4+117==i and flag==False:
            print(y, i)
            flag=True
   ```

13. накопительно нумеруем вершины графа, потом суммируем/умножаем полученные значения
 
 ![image](https://user-images.githubusercontent.com/114381884/208363284-7f150ee5-5b91-4ae4-95ca-32f9e9d1f804.png)

19, 20, 21   1) Определить точку входа (условие выигрыша, то сколько очков нужно набрать)

             2) Расписать двоичное дерево на четыре хода
             
             3) Ответить на вопрос задачи, присвоив ход игроку
             
             4) Расписывая таблицу на четыре хода, получаем решение всех трёх задач
             1) расписать через простой граф и найти минимальное значение
             2) рассматриваем два варианта позиции после первого хода
             3) расписываем для этих варинатов минимальные и максимальные дейтсвия
             4) расписываем максимальный ход пети через минимальный ход вани
             5) берем ход вани, где он делает +1 второй куче, расписываем пограничные дейтсвия......
             
   ```mermaid
stateDiagram-v2
    >=129 --> 128: +1
    >=129 --> 65: *2
    65 --> 64: +1
    64 --> 63: +1
    64 --> 32: *2
    63 --> 62: +1
    32 --> 16: *2
    32 --> 31: +1
    128 --> 64: *2
    128 --> 127: +1
    127 --> 126: +1
    126 --> 63: *2
    126 --> 125: +1
   ```
23. 1) С помощью функции product сформировать объект со всеми комбинациями искомой строки

     2) for prog in объект
     
     3) возвращаем стартовое значение в первоначальный вид (обнуляем его)
     
     4) используем continue для пропуска итераций неподходящих программ
     
     5) for x in prog - заходим в програму и анализируем команды
     
     6) проводим проверку на условия (if a == 7: break if a >= 35: break)

27А. 

     1)из-за того что мало пунктов, можем использовать перебор

     2)загружаем данные с файла в список
     
     3) избавляемся от первого элемента(он нам в работе не нужен)
     
     4) создаем переменную с длиной списка
     
     5)сдваиваем список
     
     6) используя разрез, меняем список для работы таким образом, чтобы км для которого считаем стоимость доставки всегда стоял на первом месте
     
     7)когда создаем список на основе среза, обнуляем стоимость
     
     8)считаем стоимость доставки по известной формуле
     
     9)создаем переменную для пересчета индексов элементов после середины списка(длина списка минус индекс элемента)
     
     10) считаем стоимость накоплением
     
     11)найденную стоимость н каждом км добавляем в новый список
     
     12)выводим индекс минимального элемента списка со стоимостью + 1
    
 27Б. 
 
      1) тоже самое, только вместо перебора метод итерации(приближения) и с каждым шагом приближаемся к точному определенному решению
 
      2) вся программа находится в бесконечном цикле, выход из которого- это точное решение(два раза повторяющийся ответ при  шаге один)
      
      3)большой цикл перебора организован с учетом трех переменных: старта, финиша и шага
      
      4)шг настраиваемся таким образом, чтобы было 20 равнораспределёных замеров на всей дороге
      
      5)после каждого прохода старт,финиш и шаг пересчитываются (определяем минимальную стоимость и км, которому она принадлежит)
      
      6)значение старта и финиша - диапазон поиска
      
      7) новое значение диапазона поиска- это км + шаг и км - шаг
      
      8) после перерасчета старта и финиша пересчитываем шаг
      
      9)целая часть от деления на 10
      
      10) когда шаг становится нулевым, мы присваиваем ему значение 1
